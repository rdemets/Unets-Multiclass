<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>models.internals.dataset API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>models.internals.dataset</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os, sys
import numpy as np

import matplotlib.pyplot as plt

from tqdm import tqdm

from .image_functions import Image_Functions      

class Dataset(Image_Functions):
    def __init__(self):
        &#34;&#34;&#34;Creates Dataset object that is used to manipulate the training data.
    
        Attributes
        ----------
        classes : list
            List of dictionaries containing the class name and id
            
        train_images : list
            List of images that is used as the input for the network
            
        train_ground_truth : list
            List of images that is used as the ground truth for the network
        &#34;&#34;&#34;
            
        self.classes = []
        self.train_images = []
        self.train_ground_truth = []
        
        super().__init__()
    
    #######################
    # Class id functions
    #######################
    def get_class_id(self, class_name):
        &#34;&#34;&#34;Returns the class id and adds class to list if not in list of classes.
    
        Parameters
        ----------
        class_name : str
            Identity of class that will be associated with the class id
            
        Returns
        ----------
        int
            Class id
        &#34;&#34;&#34;
        
        if len(self.classes) == 0:
            self.classes.append({&#34;class&#34;: class_name, &#34;id&#34;: 0})
            return 0
        
        for class_info in self.classes:
            # if class exist, return class id
            if class_info[&#34;class&#34;] == class_name:
                return class_info[&#34;id&#34;]
   
        self.classes.append({&#34;class&#34;: class_name, &#34;id&#34;: len(self.classes)-1})
        return len(self.classes)-1
    
    #######################
    # Class id functions
    #######################
    def sanity_check(self, image_index):
        &#34;&#34;&#34;Plots the augmented image and ground_truth to check if everything is ok.
    
        Parameters
        ----------
        image_index : int
            Index of the image and its corresponding ground_truth
        &#34;&#34;&#34;
        
        image = self.aug_images[image_index][:,:,0]
        ground_truth = self.aug_ground_truth[image_index][:,:,0]

        plt.figure(figsize=(14, 14))
        plt.axis(&#39;off&#39;)
        plt.imshow(image, cmap=&#39;gray&#39;, 
                   norm=None, interpolation=None)
        plt.show()

        plt.figure(figsize=(14, 14))
        plt.axis(&#39;off&#39;)
        plt.imshow(ground_truth, cmap=&#39;gray&#39;, 
                   norm=None, interpolation=None)
        plt.show()
    
    def load_dataset(self, dataset_dir = None, tiled = False):
        &#34;&#34;&#34;Loads dataset from ``dataset_dir``
    
        Parameters
        ----------
        dataset_dir : str or none, optional
            Folder to load the dataset from. If none, ``dataset_dir`` is obtained from config file
            
        tiled : bool, optional
            To set if tiling function is used
        &#34;&#34;&#34;
        
        # update dataset_dir if specified. If not, load dataset_dir from config file
        if dataset_dir is None:
            dataset_dir = self.config.get_parameter(&#34;dataset_dir&#34;)
        else:
            self.config.update_parameter(self.config.find_key(&#34;dataset_dir&#34;), dataset_dir)
        
        image_dirs = next(os.walk(dataset_dir))[1]
        image_dirs = [f for f in image_dirs if not f[0] == &#39;.&#39;]
        
        for img_dir in image_dirs:
            # images
            image = self.load_image(os.path.join(dataset_dir, img_dir), subfolder = self.config.get_parameter(&#34;image_subfolder&#34;))
            
            # percentile normalization
            if self.config.get_parameter(&#34;percentile_normalization&#34;):
                image, _, _ = self.percentile_normalization(image, in_bound = self.config.get_parameter(&#34;percentile&#34;))
            
            if tiled is True:
                tile_image_list, num_rows, num_cols, padding = self.tile_image(image, self.config.get_parameter(&#34;tile_size&#34;), self.config.get_parameter(&#34;tile_overlap_size&#34;))
                self.config.update_parameter([&#34;images&#34;,&#34;num_rows&#34;], num_rows)
                self.config.update_parameter([&#34;images&#34;,&#34;num_cols&#34;], num_cols)
                self.config.update_parameter([&#34;images&#34;,&#34;padding&#34;], padding)
                self.train_images.extend(tile_image_list)
            else:
                self.train_images.extend([image,])
            
            #ground_truth
            ground_truth, class_id = self.load_ground_truth(os.path.join(dataset_dir, img_dir), subfolder = self.config.get_parameter(&#34;ground_truth_subfolder&#34;))
            if tiled is True:
                tile_ground_truth_list, _, _, _ = self.tile_image(ground_truth[0], self.config.get_parameter(&#34;tile_size&#34;), self.config.get_parameter(&#34;tile_overlap_size&#34;))
                self.train_ground_truth.extend(tile_ground_truth_list)
            else:
                self.train_ground_truth.extend(ground_truth)
                
    #######################
    # Image augmentation
    #######################
    def augment_images(self):
        &#34;&#34;&#34;Augments images using the parameters in the config file&#34;&#34;&#34;
        
        # TODO: To allow for augmentation of multi-class images
        
        augmentor = self.augmentations(p=self.config.get_parameter(&#34;augmentations_p&#34;))
        
        # increase number of images
        self.aug_images = self.train_images*self.config.get_parameter(&#34;num_augmented_images&#34;)
        self.aug_ground_truth = self.train_ground_truth*self.config.get_parameter(&#34;num_augmented_images&#34;)
        
        print(&#34;Performing augmentations on {} images&#34;.format(len(self.aug_images)))
        sys.stdout.flush()
        
        for i in tqdm(range(len(self.aug_images)),desc=&#34;Augmentation of images&#34;):
            
            # target must be image and mask in order for albumentations to work
            data = {&#34;image&#34;: self.aug_images[i], 
                    &#34;mask&#34;: self.aug_ground_truth[i]}
            augmented = augmentor(**data)

            self.aug_images[i] = self.reshape_image(np.asarray(augmented[&#34;image&#34;]))
            
            # add 
            if self.config.get_parameter(&#34;use_binary_dilation_after_augmentation&#34;) is True:
                from skimage.morphology import binary_dilation, disk
                self.aug_ground_truth[i] = self.reshape_image(binary_dilation(np.ndarray.astype(augmented[&#34;mask&#34;], np.bool), disk(self.config.get_parameter(&#34;disk_size&#34;))))
            else:
                self.aug_ground_truth[i] = self.reshape_image(np.ndarray.astype(augmented[&#34;mask&#34;], np.bool))

        self.aug_images = np.stack(self.aug_images, axis = 0)
        self.aug_ground_truth = np.stack(self.aug_ground_truth, axis = 0)
        
        mean = self.aug_images.mean()
        std = self.aug_images.std()
        
        self.config.update_parameter([&#34;images&#34;,&#34;mean&#34;], float(mean))
        self.config.update_parameter([&#34;images&#34;,&#34;std&#34;], float(std))
        
        print(&#34;Augmentations complete!&#34;)

    def augmentations(self, p = None):
        &#34;&#34;&#34;Generates list of augmentations using parameters obtained from config file
        
        Parameters
        ----------
        p : int, optional
            probability to apply any augmentations to image
        
        Returns
        ----------
        function
            function used to augment images
        &#34;&#34;&#34;
        from albumentations import (
            RandomCrop, HorizontalFlip, IAAPerspective, ShiftScaleRotate, CLAHE, RandomRotate90,
            Transpose, ShiftScaleRotate, Blur, OpticalDistortion, GridDistortion, ElasticTransform,
            IAAAdditiveGaussianNoise, GaussNoise, MotionBlur, MedianBlur,
            IAASharpen, RandomBrightnessContrast, Flip, OneOf, Compose
        )
        
        augmentation_list = []
        
        if self.config.get_parameter(&#34;random_rotate&#34;) is True:
            augmentation_list.append(RandomRotate90(p = self.config.get_parameter(&#34;random_rotate_p&#34;))) # 0.9
        
        if self.config.get_parameter(&#34;flip&#34;) is True:
            augmentation_list.append(Flip())
            
        if self.config.get_parameter(&#34;transpose&#34;) is True:
            augmentation_list.append(Transpose())
            
        if self.config.get_parameter(&#34;blur_group&#34;) is True:
            blur_augmentation = []
            if self.config.get_parameter(&#34;motion_blur&#34;) is True:
                blur_augmentation.append(MotionBlur(p = self.config.get_parameter(&#34;motion_blur_p&#34;)))
            if self.config.get_parameter(&#34;median_blur&#34;) is True:
                blur_augmentation.append(MedianBlur(blur_limit = self.config.get_parameter(&#34;median_blur_limit&#34;), p = self.config.get_parameter(&#34;median_blur_p&#34;)))
            if self.config.get_parameter(&#34;blur&#34;) is True:
                blur_augmentation.append(Blur(blur_limit = self.config.get_parameter(&#34;blur_limit&#34;), p = self.config.get_parameter(&#34;blur_p&#34;)))
            augmentation_list.append(OneOf(blur_augmentation, p = self.config.get_parameter(&#34;blur_group_p&#34;))) 
            
        if self.config.get_parameter(&#34;shift_scale_rotate&#34;) is True:
            augmentation_list.append(ShiftScaleRotate(shift_limit = self.config.get_parameter(&#34;shift_limit&#34;),
                                                      scale_limit = self.config.get_parameter(&#34;scale_limit&#34;),
                                                      rotate_limit = self.config.get_parameter(&#34;rotate_limit&#34;),
                                                      p = self.config.get_parameter(&#34;shift_scale_rotate_p&#34;)))
        if self.config.get_parameter(&#34;distortion_group&#34;) is True:
            distortion_augmentation = []
            if self.config.get_parameter(&#34;optical_distortion&#34;) is True:
                distortion_augmentation.append(OpticalDistortion(p = self.config.get_parameter(&#34;optical_distortion_p&#34;)))
            if self.config.get_parameter(&#34;elastic_transform&#34;) is True:
                distortion_augmentation.append(ElasticTransform(p = self.config.get_parameter(&#34;elastic_transform_p&#34;)))
            if self.config.get_parameter(&#34;grid_distortion&#34;) is True:
                distortion_augmentation.append(GridDistortion(p = self.config.get_parameter(&#34;grid_distortion_p&#34;)))
            
            augmentation_list.append(OneOf(distortion_augmentation, p = self.config.get_parameter(&#34;distortion_group_p&#34;)))
        
        if self.config.get_parameter(&#34;brightness_contrast_group&#34;) is True:
            contrast_augmentation = []
            if self.config.get_parameter(&#34;clahe&#34;) is True:
                contrast_augmentation.append(CLAHE())
            if self.config.get_parameter(&#34;sharpen&#34;) is True:
                contrast_augmentation.append(IAASharpen())
            if self.config.get_parameter(&#34;random_brightness_contrast&#34;) is True:
                contrast_augmentation.append(RandomBrightnessContrast())
           
            augmentation_list.append(OneOf(contrast_augmentation, p = self.config.get_parameter(&#34;brightness_contrast_group_p&#34;)))
            
        augmentation_list.append(RandomCrop(self.config.get_parameter(&#34;tile_size&#34;)[0], self.config.get_parameter(&#34;tile_size&#34;)[1], always_apply=True))
        
        return Compose(augmentation_list, p = p)

############################### TODO ###############################
#     def preapare_data(self):
#         &#34;&#34;&#34;        
#         Performs augmentation if needed
#         &#34;&#34;&#34;
        
            
#     # Create data generator
#     # Return augmented images/ground_truth arrays of batch size
#     def generator(features, labels, batch_size, seq_det):
#         # create empty arrays to contain batch of features and labels
#         batch_features = np.zeros((batch_size, features.shape[1], features.shape[2], features.shape[3]))
#         batch_labels = np.zeros((batch_size, labels.shape[1], labels.shape[2], labels.shape[3]))

#         while True:
#             # Fill arrays of batch size with augmented data taken randomly from full passed arrays
#             indexes = random.sample(range(len(features)), batch_size)
#             # Perform the exactly the same augmentation for X and y
#             random_augmented_images, random_augmented_labels = do_augmentation(seq_det, features[indexes], labels[indexes])
#             batch_features[:,:,:,:] = random_augmented_images[:,:,:,:]
#             batch_labels[:,:,:,:] = random_augmented_labels[:,:,:,:]

#             yield batch_features, batch_labels
            
    # Train augmentation
#     def do_augmentation(seq_det, X_train, y_train):
#         # Use seq_det to build augmentation.
#         # ....
#         return np.array(X_train_aug), np.array(y_train_aug)

#     seq = iaa.Sequential([
#         iaa.Fliplr(0.5), # horizontally flip
#         iaa.OneOf([
#             iaa.Noop(),
#             iaa.GaussianBlur(sigma=(0.0, 1.0)),
#             iaa.Noop(),
#             iaa.Affine(rotate=(-10, 10), translate_percent={&#34;x&#34;: (-0.25, 0.25)}, mode=&#39;symmetric&#39;, cval=(0)),
#             iaa.Noop(),
#             iaa.PerspectiveTransform(scale=(0.04, 0.08)),
#             iaa.Noop(),
#             iaa.PiecewiseAffine(scale=(0.05, 0.1), mode=&#39;edge&#39;, cval=(0)),
#         ]),
#         # More as you want ...
#     ])
#     seq_det = seq.to_deterministic()
    
#     history = model.fit_generator(generator(X_train, y_train, BATCH_SIZE, seq_det),
#                               epochs=EPOCHS,
#                               steps_per_epoch=steps_per_epoch,
#                               validation_data=(X_valid, y_valid),
#                               verbose = 1, 
#                               callbacks = [check_point]
#                              ) 
    
    # Image augmentations
            
############################### END of TODO ###############################</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="models.internals.dataset.Dataset"><code class="flex name class">
<span>class <span class="ident">Dataset</span></span>
</code></dt>
<dd>
<section class="desc"><p>Creates Dataset object that is used to manipulate the training data.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>classes</code></strong> :&ensp;<code>list</code></dt>
<dd>List of dictionaries containing the class name and id</dd>
<dt><strong><code>train_images</code></strong> :&ensp;<code>list</code></dt>
<dd>List of images that is used as the input for the network</dd>
<dt><strong><code>train_ground_truth</code></strong> :&ensp;<code>list</code></dt>
<dd>List of images that is used as the ground truth for the network</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dataset(Image_Functions):
    def __init__(self):
        &#34;&#34;&#34;Creates Dataset object that is used to manipulate the training data.
    
        Attributes
        ----------
        classes : list
            List of dictionaries containing the class name and id
            
        train_images : list
            List of images that is used as the input for the network
            
        train_ground_truth : list
            List of images that is used as the ground truth for the network
        &#34;&#34;&#34;
            
        self.classes = []
        self.train_images = []
        self.train_ground_truth = []
        
        super().__init__()
    
    #######################
    # Class id functions
    #######################
    def get_class_id(self, class_name):
        &#34;&#34;&#34;Returns the class id and adds class to list if not in list of classes.
    
        Parameters
        ----------
        class_name : str
            Identity of class that will be associated with the class id
            
        Returns
        ----------
        int
            Class id
        &#34;&#34;&#34;
        
        if len(self.classes) == 0:
            self.classes.append({&#34;class&#34;: class_name, &#34;id&#34;: 0})
            return 0
        
        for class_info in self.classes:
            # if class exist, return class id
            if class_info[&#34;class&#34;] == class_name:
                return class_info[&#34;id&#34;]
   
        self.classes.append({&#34;class&#34;: class_name, &#34;id&#34;: len(self.classes)-1})
        return len(self.classes)-1
    
    #######################
    # Class id functions
    #######################
    def sanity_check(self, image_index):
        &#34;&#34;&#34;Plots the augmented image and ground_truth to check if everything is ok.
    
        Parameters
        ----------
        image_index : int
            Index of the image and its corresponding ground_truth
        &#34;&#34;&#34;
        
        image = self.aug_images[image_index][:,:,0]
        ground_truth = self.aug_ground_truth[image_index][:,:,0]

        plt.figure(figsize=(14, 14))
        plt.axis(&#39;off&#39;)
        plt.imshow(image, cmap=&#39;gray&#39;, 
                   norm=None, interpolation=None)
        plt.show()

        plt.figure(figsize=(14, 14))
        plt.axis(&#39;off&#39;)
        plt.imshow(ground_truth, cmap=&#39;gray&#39;, 
                   norm=None, interpolation=None)
        plt.show()
    
    def load_dataset(self, dataset_dir = None, tiled = False):
        &#34;&#34;&#34;Loads dataset from ``dataset_dir``
    
        Parameters
        ----------
        dataset_dir : str or none, optional
            Folder to load the dataset from. If none, ``dataset_dir`` is obtained from config file
            
        tiled : bool, optional
            To set if tiling function is used
        &#34;&#34;&#34;
        
        # update dataset_dir if specified. If not, load dataset_dir from config file
        if dataset_dir is None:
            dataset_dir = self.config.get_parameter(&#34;dataset_dir&#34;)
        else:
            self.config.update_parameter(self.config.find_key(&#34;dataset_dir&#34;), dataset_dir)
        
        image_dirs = next(os.walk(dataset_dir))[1]
        image_dirs = [f for f in image_dirs if not f[0] == &#39;.&#39;]
        
        for img_dir in image_dirs:
            # images
            image = self.load_image(os.path.join(dataset_dir, img_dir), subfolder = self.config.get_parameter(&#34;image_subfolder&#34;))
            
            # percentile normalization
            if self.config.get_parameter(&#34;percentile_normalization&#34;):
                image, _, _ = self.percentile_normalization(image, in_bound = self.config.get_parameter(&#34;percentile&#34;))
            
            if tiled is True:
                tile_image_list, num_rows, num_cols, padding = self.tile_image(image, self.config.get_parameter(&#34;tile_size&#34;), self.config.get_parameter(&#34;tile_overlap_size&#34;))
                self.config.update_parameter([&#34;images&#34;,&#34;num_rows&#34;], num_rows)
                self.config.update_parameter([&#34;images&#34;,&#34;num_cols&#34;], num_cols)
                self.config.update_parameter([&#34;images&#34;,&#34;padding&#34;], padding)
                self.train_images.extend(tile_image_list)
            else:
                self.train_images.extend([image,])
            
            #ground_truth
            ground_truth, class_id = self.load_ground_truth(os.path.join(dataset_dir, img_dir), subfolder = self.config.get_parameter(&#34;ground_truth_subfolder&#34;))
            if tiled is True:
                tile_ground_truth_list, _, _, _ = self.tile_image(ground_truth[0], self.config.get_parameter(&#34;tile_size&#34;), self.config.get_parameter(&#34;tile_overlap_size&#34;))
                self.train_ground_truth.extend(tile_ground_truth_list)
            else:
                self.train_ground_truth.extend(ground_truth)
                
    #######################
    # Image augmentation
    #######################
    def augment_images(self):
        &#34;&#34;&#34;Augments images using the parameters in the config file&#34;&#34;&#34;
        
        # TODO: To allow for augmentation of multi-class images
        
        augmentor = self.augmentations(p=self.config.get_parameter(&#34;augmentations_p&#34;))
        
        # increase number of images
        self.aug_images = self.train_images*self.config.get_parameter(&#34;num_augmented_images&#34;)
        self.aug_ground_truth = self.train_ground_truth*self.config.get_parameter(&#34;num_augmented_images&#34;)
        
        print(&#34;Performing augmentations on {} images&#34;.format(len(self.aug_images)))
        sys.stdout.flush()
        
        for i in tqdm(range(len(self.aug_images)),desc=&#34;Augmentation of images&#34;):
            
            # target must be image and mask in order for albumentations to work
            data = {&#34;image&#34;: self.aug_images[i], 
                    &#34;mask&#34;: self.aug_ground_truth[i]}
            augmented = augmentor(**data)

            self.aug_images[i] = self.reshape_image(np.asarray(augmented[&#34;image&#34;]))
            
            # add 
            if self.config.get_parameter(&#34;use_binary_dilation_after_augmentation&#34;) is True:
                from skimage.morphology import binary_dilation, disk
                self.aug_ground_truth[i] = self.reshape_image(binary_dilation(np.ndarray.astype(augmented[&#34;mask&#34;], np.bool), disk(self.config.get_parameter(&#34;disk_size&#34;))))
            else:
                self.aug_ground_truth[i] = self.reshape_image(np.ndarray.astype(augmented[&#34;mask&#34;], np.bool))

        self.aug_images = np.stack(self.aug_images, axis = 0)
        self.aug_ground_truth = np.stack(self.aug_ground_truth, axis = 0)
        
        mean = self.aug_images.mean()
        std = self.aug_images.std()
        
        self.config.update_parameter([&#34;images&#34;,&#34;mean&#34;], float(mean))
        self.config.update_parameter([&#34;images&#34;,&#34;std&#34;], float(std))
        
        print(&#34;Augmentations complete!&#34;)

    def augmentations(self, p = None):
        &#34;&#34;&#34;Generates list of augmentations using parameters obtained from config file
        
        Parameters
        ----------
        p : int, optional
            probability to apply any augmentations to image
        
        Returns
        ----------
        function
            function used to augment images
        &#34;&#34;&#34;
        from albumentations import (
            RandomCrop, HorizontalFlip, IAAPerspective, ShiftScaleRotate, CLAHE, RandomRotate90,
            Transpose, ShiftScaleRotate, Blur, OpticalDistortion, GridDistortion, ElasticTransform,
            IAAAdditiveGaussianNoise, GaussNoise, MotionBlur, MedianBlur,
            IAASharpen, RandomBrightnessContrast, Flip, OneOf, Compose
        )
        
        augmentation_list = []
        
        if self.config.get_parameter(&#34;random_rotate&#34;) is True:
            augmentation_list.append(RandomRotate90(p = self.config.get_parameter(&#34;random_rotate_p&#34;))) # 0.9
        
        if self.config.get_parameter(&#34;flip&#34;) is True:
            augmentation_list.append(Flip())
            
        if self.config.get_parameter(&#34;transpose&#34;) is True:
            augmentation_list.append(Transpose())
            
        if self.config.get_parameter(&#34;blur_group&#34;) is True:
            blur_augmentation = []
            if self.config.get_parameter(&#34;motion_blur&#34;) is True:
                blur_augmentation.append(MotionBlur(p = self.config.get_parameter(&#34;motion_blur_p&#34;)))
            if self.config.get_parameter(&#34;median_blur&#34;) is True:
                blur_augmentation.append(MedianBlur(blur_limit = self.config.get_parameter(&#34;median_blur_limit&#34;), p = self.config.get_parameter(&#34;median_blur_p&#34;)))
            if self.config.get_parameter(&#34;blur&#34;) is True:
                blur_augmentation.append(Blur(blur_limit = self.config.get_parameter(&#34;blur_limit&#34;), p = self.config.get_parameter(&#34;blur_p&#34;)))
            augmentation_list.append(OneOf(blur_augmentation, p = self.config.get_parameter(&#34;blur_group_p&#34;))) 
            
        if self.config.get_parameter(&#34;shift_scale_rotate&#34;) is True:
            augmentation_list.append(ShiftScaleRotate(shift_limit = self.config.get_parameter(&#34;shift_limit&#34;),
                                                      scale_limit = self.config.get_parameter(&#34;scale_limit&#34;),
                                                      rotate_limit = self.config.get_parameter(&#34;rotate_limit&#34;),
                                                      p = self.config.get_parameter(&#34;shift_scale_rotate_p&#34;)))
        if self.config.get_parameter(&#34;distortion_group&#34;) is True:
            distortion_augmentation = []
            if self.config.get_parameter(&#34;optical_distortion&#34;) is True:
                distortion_augmentation.append(OpticalDistortion(p = self.config.get_parameter(&#34;optical_distortion_p&#34;)))
            if self.config.get_parameter(&#34;elastic_transform&#34;) is True:
                distortion_augmentation.append(ElasticTransform(p = self.config.get_parameter(&#34;elastic_transform_p&#34;)))
            if self.config.get_parameter(&#34;grid_distortion&#34;) is True:
                distortion_augmentation.append(GridDistortion(p = self.config.get_parameter(&#34;grid_distortion_p&#34;)))
            
            augmentation_list.append(OneOf(distortion_augmentation, p = self.config.get_parameter(&#34;distortion_group_p&#34;)))
        
        if self.config.get_parameter(&#34;brightness_contrast_group&#34;) is True:
            contrast_augmentation = []
            if self.config.get_parameter(&#34;clahe&#34;) is True:
                contrast_augmentation.append(CLAHE())
            if self.config.get_parameter(&#34;sharpen&#34;) is True:
                contrast_augmentation.append(IAASharpen())
            if self.config.get_parameter(&#34;random_brightness_contrast&#34;) is True:
                contrast_augmentation.append(RandomBrightnessContrast())
           
            augmentation_list.append(OneOf(contrast_augmentation, p = self.config.get_parameter(&#34;brightness_contrast_group_p&#34;)))
            
        augmentation_list.append(RandomCrop(self.config.get_parameter(&#34;tile_size&#34;)[0], self.config.get_parameter(&#34;tile_size&#34;)[1], always_apply=True))
        
        return Compose(augmentation_list, p = p)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="models.internals.image_functions.Image_Functions" href="image_functions.html#models.internals.image_functions.Image_Functions">Image_Functions</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="models.CNN_Base.CNN_Base" href="../CNN_Base.html#models.CNN_Base.CNN_Base">CNN_Base</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="models.internals.dataset.Dataset.augment_images"><code class="name flex">
<span>def <span class="ident">augment_images</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Augments images using the parameters in the config file</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def augment_images(self):
    &#34;&#34;&#34;Augments images using the parameters in the config file&#34;&#34;&#34;
    
    # TODO: To allow for augmentation of multi-class images
    
    augmentor = self.augmentations(p=self.config.get_parameter(&#34;augmentations_p&#34;))
    
    # increase number of images
    self.aug_images = self.train_images*self.config.get_parameter(&#34;num_augmented_images&#34;)
    self.aug_ground_truth = self.train_ground_truth*self.config.get_parameter(&#34;num_augmented_images&#34;)
    
    print(&#34;Performing augmentations on {} images&#34;.format(len(self.aug_images)))
    sys.stdout.flush()
    
    for i in tqdm(range(len(self.aug_images)),desc=&#34;Augmentation of images&#34;):
        
        # target must be image and mask in order for albumentations to work
        data = {&#34;image&#34;: self.aug_images[i], 
                &#34;mask&#34;: self.aug_ground_truth[i]}
        augmented = augmentor(**data)

        self.aug_images[i] = self.reshape_image(np.asarray(augmented[&#34;image&#34;]))
        
        # add 
        if self.config.get_parameter(&#34;use_binary_dilation_after_augmentation&#34;) is True:
            from skimage.morphology import binary_dilation, disk
            self.aug_ground_truth[i] = self.reshape_image(binary_dilation(np.ndarray.astype(augmented[&#34;mask&#34;], np.bool), disk(self.config.get_parameter(&#34;disk_size&#34;))))
        else:
            self.aug_ground_truth[i] = self.reshape_image(np.ndarray.astype(augmented[&#34;mask&#34;], np.bool))

    self.aug_images = np.stack(self.aug_images, axis = 0)
    self.aug_ground_truth = np.stack(self.aug_ground_truth, axis = 0)
    
    mean = self.aug_images.mean()
    std = self.aug_images.std()
    
    self.config.update_parameter([&#34;images&#34;,&#34;mean&#34;], float(mean))
    self.config.update_parameter([&#34;images&#34;,&#34;std&#34;], float(std))
    
    print(&#34;Augmentations complete!&#34;)</code></pre>
</details>
</dd>
<dt id="models.internals.dataset.Dataset.augmentations"><code class="name flex">
<span>def <span class="ident">augmentations</span></span>(<span>self, p=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates list of augmentations using parameters obtained from config file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>probability to apply any augmentations to image</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>function</code></dt>
<dd>function used to augment images</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def augmentations(self, p = None):
    &#34;&#34;&#34;Generates list of augmentations using parameters obtained from config file
    
    Parameters
    ----------
    p : int, optional
        probability to apply any augmentations to image
    
    Returns
    ----------
    function
        function used to augment images
    &#34;&#34;&#34;
    from albumentations import (
        RandomCrop, HorizontalFlip, IAAPerspective, ShiftScaleRotate, CLAHE, RandomRotate90,
        Transpose, ShiftScaleRotate, Blur, OpticalDistortion, GridDistortion, ElasticTransform,
        IAAAdditiveGaussianNoise, GaussNoise, MotionBlur, MedianBlur,
        IAASharpen, RandomBrightnessContrast, Flip, OneOf, Compose
    )
    
    augmentation_list = []
    
    if self.config.get_parameter(&#34;random_rotate&#34;) is True:
        augmentation_list.append(RandomRotate90(p = self.config.get_parameter(&#34;random_rotate_p&#34;))) # 0.9
    
    if self.config.get_parameter(&#34;flip&#34;) is True:
        augmentation_list.append(Flip())
        
    if self.config.get_parameter(&#34;transpose&#34;) is True:
        augmentation_list.append(Transpose())
        
    if self.config.get_parameter(&#34;blur_group&#34;) is True:
        blur_augmentation = []
        if self.config.get_parameter(&#34;motion_blur&#34;) is True:
            blur_augmentation.append(MotionBlur(p = self.config.get_parameter(&#34;motion_blur_p&#34;)))
        if self.config.get_parameter(&#34;median_blur&#34;) is True:
            blur_augmentation.append(MedianBlur(blur_limit = self.config.get_parameter(&#34;median_blur_limit&#34;), p = self.config.get_parameter(&#34;median_blur_p&#34;)))
        if self.config.get_parameter(&#34;blur&#34;) is True:
            blur_augmentation.append(Blur(blur_limit = self.config.get_parameter(&#34;blur_limit&#34;), p = self.config.get_parameter(&#34;blur_p&#34;)))
        augmentation_list.append(OneOf(blur_augmentation, p = self.config.get_parameter(&#34;blur_group_p&#34;))) 
        
    if self.config.get_parameter(&#34;shift_scale_rotate&#34;) is True:
        augmentation_list.append(ShiftScaleRotate(shift_limit = self.config.get_parameter(&#34;shift_limit&#34;),
                                                  scale_limit = self.config.get_parameter(&#34;scale_limit&#34;),
                                                  rotate_limit = self.config.get_parameter(&#34;rotate_limit&#34;),
                                                  p = self.config.get_parameter(&#34;shift_scale_rotate_p&#34;)))
    if self.config.get_parameter(&#34;distortion_group&#34;) is True:
        distortion_augmentation = []
        if self.config.get_parameter(&#34;optical_distortion&#34;) is True:
            distortion_augmentation.append(OpticalDistortion(p = self.config.get_parameter(&#34;optical_distortion_p&#34;)))
        if self.config.get_parameter(&#34;elastic_transform&#34;) is True:
            distortion_augmentation.append(ElasticTransform(p = self.config.get_parameter(&#34;elastic_transform_p&#34;)))
        if self.config.get_parameter(&#34;grid_distortion&#34;) is True:
            distortion_augmentation.append(GridDistortion(p = self.config.get_parameter(&#34;grid_distortion_p&#34;)))
        
        augmentation_list.append(OneOf(distortion_augmentation, p = self.config.get_parameter(&#34;distortion_group_p&#34;)))
    
    if self.config.get_parameter(&#34;brightness_contrast_group&#34;) is True:
        contrast_augmentation = []
        if self.config.get_parameter(&#34;clahe&#34;) is True:
            contrast_augmentation.append(CLAHE())
        if self.config.get_parameter(&#34;sharpen&#34;) is True:
            contrast_augmentation.append(IAASharpen())
        if self.config.get_parameter(&#34;random_brightness_contrast&#34;) is True:
            contrast_augmentation.append(RandomBrightnessContrast())
       
        augmentation_list.append(OneOf(contrast_augmentation, p = self.config.get_parameter(&#34;brightness_contrast_group_p&#34;)))
        
    augmentation_list.append(RandomCrop(self.config.get_parameter(&#34;tile_size&#34;)[0], self.config.get_parameter(&#34;tile_size&#34;)[1], always_apply=True))
    
    return Compose(augmentation_list, p = p)</code></pre>
</details>
</dd>
<dt id="models.internals.dataset.Dataset.get_class_id"><code class="name flex">
<span>def <span class="ident">get_class_id</span></span>(<span>self, class_name)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the class id and adds class to list if not in list of classes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>class_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Identity of class that will be associated with the class id</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Class id</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_class_id(self, class_name):
    &#34;&#34;&#34;Returns the class id and adds class to list if not in list of classes.

    Parameters
    ----------
    class_name : str
        Identity of class that will be associated with the class id
        
    Returns
    ----------
    int
        Class id
    &#34;&#34;&#34;
    
    if len(self.classes) == 0:
        self.classes.append({&#34;class&#34;: class_name, &#34;id&#34;: 0})
        return 0
    
    for class_info in self.classes:
        # if class exist, return class id
        if class_info[&#34;class&#34;] == class_name:
            return class_info[&#34;id&#34;]

    self.classes.append({&#34;class&#34;: class_name, &#34;id&#34;: len(self.classes)-1})
    return len(self.classes)-1</code></pre>
</details>
</dd>
<dt id="models.internals.dataset.Dataset.load_dataset"><code class="name flex">
<span>def <span class="ident">load_dataset</span></span>(<span>self, dataset_dir=None, tiled=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Loads dataset from <code>dataset_dir</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dataset_dir</code></strong> :&ensp;<code>str</code> or <code>none</code>, optional</dt>
<dd>Folder to load the dataset from. If none, <code>dataset_dir</code> is obtained from config file</dd>
<dt><strong><code>tiled</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>To set if tiling function is used</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_dataset(self, dataset_dir = None, tiled = False):
    &#34;&#34;&#34;Loads dataset from ``dataset_dir``

    Parameters
    ----------
    dataset_dir : str or none, optional
        Folder to load the dataset from. If none, ``dataset_dir`` is obtained from config file
        
    tiled : bool, optional
        To set if tiling function is used
    &#34;&#34;&#34;
    
    # update dataset_dir if specified. If not, load dataset_dir from config file
    if dataset_dir is None:
        dataset_dir = self.config.get_parameter(&#34;dataset_dir&#34;)
    else:
        self.config.update_parameter(self.config.find_key(&#34;dataset_dir&#34;), dataset_dir)
    
    image_dirs = next(os.walk(dataset_dir))[1]
    image_dirs = [f for f in image_dirs if not f[0] == &#39;.&#39;]
    
    for img_dir in image_dirs:
        # images
        image = self.load_image(os.path.join(dataset_dir, img_dir), subfolder = self.config.get_parameter(&#34;image_subfolder&#34;))
        
        # percentile normalization
        if self.config.get_parameter(&#34;percentile_normalization&#34;):
            image, _, _ = self.percentile_normalization(image, in_bound = self.config.get_parameter(&#34;percentile&#34;))
        
        if tiled is True:
            tile_image_list, num_rows, num_cols, padding = self.tile_image(image, self.config.get_parameter(&#34;tile_size&#34;), self.config.get_parameter(&#34;tile_overlap_size&#34;))
            self.config.update_parameter([&#34;images&#34;,&#34;num_rows&#34;], num_rows)
            self.config.update_parameter([&#34;images&#34;,&#34;num_cols&#34;], num_cols)
            self.config.update_parameter([&#34;images&#34;,&#34;padding&#34;], padding)
            self.train_images.extend(tile_image_list)
        else:
            self.train_images.extend([image,])
        
        #ground_truth
        ground_truth, class_id = self.load_ground_truth(os.path.join(dataset_dir, img_dir), subfolder = self.config.get_parameter(&#34;ground_truth_subfolder&#34;))
        if tiled is True:
            tile_ground_truth_list, _, _, _ = self.tile_image(ground_truth[0], self.config.get_parameter(&#34;tile_size&#34;), self.config.get_parameter(&#34;tile_overlap_size&#34;))
            self.train_ground_truth.extend(tile_ground_truth_list)
        else:
            self.train_ground_truth.extend(ground_truth)</code></pre>
</details>
</dd>
<dt id="models.internals.dataset.Dataset.sanity_check"><code class="name flex">
<span>def <span class="ident">sanity_check</span></span>(<span>self, image_index)</span>
</code></dt>
<dd>
<section class="desc"><p>Plots the augmented image and ground_truth to check if everything is ok.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the image and its corresponding ground_truth</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sanity_check(self, image_index):
    &#34;&#34;&#34;Plots the augmented image and ground_truth to check if everything is ok.

    Parameters
    ----------
    image_index : int
        Index of the image and its corresponding ground_truth
    &#34;&#34;&#34;
    
    image = self.aug_images[image_index][:,:,0]
    ground_truth = self.aug_ground_truth[image_index][:,:,0]

    plt.figure(figsize=(14, 14))
    plt.axis(&#39;off&#39;)
    plt.imshow(image, cmap=&#39;gray&#39;, 
               norm=None, interpolation=None)
    plt.show()

    plt.figure(figsize=(14, 14))
    plt.axis(&#39;off&#39;)
    plt.imshow(ground_truth, cmap=&#39;gray&#39;, 
               norm=None, interpolation=None)
    plt.show()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="models.internals.image_functions.Image_Functions" href="image_functions.html#models.internals.image_functions.Image_Functions">Image_Functions</a></b></code>:
<ul class="hlist">
<li><code><a title="models.internals.image_functions.Image_Functions.list_images" href="image_functions.html#models.internals.image_functions.Image_Functions.list_images">list_images</a></code></li>
<li><code><a title="models.internals.image_functions.Image_Functions.load_ground_truth" href="image_functions.html#models.internals.image_functions.Image_Functions.load_ground_truth">load_ground_truth</a></code></li>
<li><code><a title="models.internals.image_functions.Image_Functions.load_image" href="image_functions.html#models.internals.image_functions.Image_Functions.load_image">load_image</a></code></li>
<li><code><a title="models.internals.image_functions.Image_Functions.pad_image" href="image_functions.html#models.internals.image_functions.Image_Functions.pad_image">pad_image</a></code></li>
<li><code><a title="models.internals.image_functions.Image_Functions.percentile_normalization" href="image_functions.html#models.internals.image_functions.Image_Functions.percentile_normalization">percentile_normalization</a></code></li>
<li><code><a title="models.internals.image_functions.Image_Functions.remove_pad_image" href="image_functions.html#models.internals.image_functions.Image_Functions.remove_pad_image">remove_pad_image</a></code></li>
<li><code><a title="models.internals.image_functions.Image_Functions.reshape_image" href="image_functions.html#models.internals.image_functions.Image_Functions.reshape_image">reshape_image</a></code></li>
<li><code><a title="models.internals.image_functions.Image_Functions.tile_image" href="image_functions.html#models.internals.image_functions.Image_Functions.tile_image">tile_image</a></code></li>
<li><code><a title="models.internals.image_functions.Image_Functions.untile_image" href="image_functions.html#models.internals.image_functions.Image_Functions.untile_image">untile_image</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="models.internals" href="index.html">models.internals</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="models.internals.dataset.Dataset" href="#models.internals.dataset.Dataset">Dataset</a></code></h4>
<ul class="">
<li><code><a title="models.internals.dataset.Dataset.augment_images" href="#models.internals.dataset.Dataset.augment_images">augment_images</a></code></li>
<li><code><a title="models.internals.dataset.Dataset.augmentations" href="#models.internals.dataset.Dataset.augmentations">augmentations</a></code></li>
<li><code><a title="models.internals.dataset.Dataset.get_class_id" href="#models.internals.dataset.Dataset.get_class_id">get_class_id</a></code></li>
<li><code><a title="models.internals.dataset.Dataset.load_dataset" href="#models.internals.dataset.Dataset.load_dataset">load_dataset</a></code></li>
<li><code><a title="models.internals.dataset.Dataset.sanity_check" href="#models.internals.dataset.Dataset.sanity_check">sanity_check</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>